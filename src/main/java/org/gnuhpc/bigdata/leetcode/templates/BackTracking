当遇到一个可以用到回溯法的时候脑子中有决策树，需要按照如下步骤进行：
1. 确定问题的一个解空间树， 这个解空间树至少包含一个你需要的那个解， 否则这个树就完全没有意义了
2. 组织好这棵树， 弄明白这棵树的每一个节点代表什么， 每一个分支代表什么
3. 从这棵树的根节点不断的向下深搜， 当遇到不合适的节点的时候直接跳过以这个节点为根的子树
4. 当搜索到了叶子节点的时候就回溯
5. 不断的重复这个3， 4步骤

什么时候只用DFS不用回溯：
如果DFS进去visited的值需要保留的，则不进行回溯, 比如LC200

回溯问题框架：
1)设置visited为全局数组,
2)遍历所有节点进行如下dfs

    void dfs(int 当前状态){
        if(invalid条件) return // 这一步是可选的
        if(当前状态为边界状态)
        {
            记录或输出
            return;
        }

        标记visited
        for(i=0;i<n;i++)		//横向遍历所有相邻子节点
        {
              if(子状态满足约束条件)
              {
                  做选择
                  dfs(子状态)
                  撤销选择
              }
        }
    }

LC相关题目
39 解法1

0. 解决留不留这个元素的问题：框架是robot方法，顾名思义是机器人方法
这个机器人放出去就是为了用一个数字标记选择不选择某个元素的
Step1: 设置一个selected数组，长度与大集合相同
Step2：robot(0, sets)开始进入数组进行标记
robot先判断是不是到了要收集结果集的条件，如果到了就遍历原集合并对照对应的selected，
碰到true 的就放入临时结果集，最后将临时结果集放入最终结果集

如果没到终止条件就往下标注
先标注对应selected为true，进行下一个robot(idx + 1, nums)标注
然后再标注对应selected为false，进行下一个robot(idx + 1, nums)标注

与 原始的backtracking的模板相比，结束条件和边界条件都是一样，但是他没有for循环
只考虑当前值选与不选两种情况

LC相关题目
77解法2
39解法2
78解法4
90解法2

1. 二维数组回溯架构
1.1 定义全局变量
    private int[][] dr = {
            {1, 0}, {-1, 0}, {0, 1}, {0, -1}
    };
    private int m, n;
    private boolean[][] visited;

1.2 主程序判断边界，准备全局变量
    m = board.length;
    n = board[0].length;
    visited = new boolean[m][n];

1.3 逐行逐列进行，什么都不判断
   for (int i = 0; i < m; ++i) {
       for (int j = 0; j < n; ++j)
           dfs(board, i, j, xxx, resultSet);
   }

1.4 在dfs中 (5步曲：结果集->剪枝->标注->判断valid->遍历)
   1.4.1 判断是否可以剪枝：是否可以往结果集加入临时结果集或者是否符合往下再进行的条件
   1.4.2 标注此节点visited: visited[x][y] = true;
   1.4.3 对dr进行遍历，得到newX和newY，判断节点是不是越界并没有被访问过，如果满足则dfs进入newX和newY
           for (int[] d : dr) {
               int newX = x + d[0];
               int newY = y + d[1];
               if (isValid(newX, newY)) {
                   dfs(board, newX, newY, node, result);
               }
           }

    其中在遍历的时候判断是不是越界,以及是不是访问过(重点！！！):
    public boolean isValid(int x, int y) {
        return (x >= 0 && x < m && y >= 0 && y < n) && !visited[x][y];
    }
   1.4.4 （尝试型的题目需要）回溯，去标注此节点visited: visited[x][y] = false;

LC相关题目：
79, 212(加了Trie 快速剪枝), 329

2. 在遍历中需要带着上一步的状态的，直接使用dfs返回数值即可
在DFS函数中直接定义这个值就行，要么不断算最值，要么累加累乘
LC相关题目：
64
63
351
980

3. 有时候不是一个个单元格，而是一列列或者一行行进行的
LC相关题目
51

4.


5. 有时候选择个数是有限的，所以可以将选择个数剩余放入函数中

LC相关题目
78

