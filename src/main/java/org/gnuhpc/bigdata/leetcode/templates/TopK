TopK问题一般有两种情况: 求第K个最大的/求前K个最大的

1. 使用PriorityQueue (通解)
记忆要点:求最大的k个数 则用最小堆,反之用最大堆
步骤:(以求最大k为例)
1) 构建最小堆
2) 往里面依次添加元素,直到堆的size 等于k, 堆顶放的就是最小的数字,也就是最可能被淘汰的
3) 接着取数字,如果发现取出来的数字比堆顶大,说明堆顶的数字不是最终结果,因此poll出来,然后将新取的数字塞进去,由于堆的特性,堆顶还是最小的,
   也就是最可能被淘汰的.
4) 如此往复存下其余数字, 最后堆里面剩下的k个数字便是最大的k个数,而堆顶就是第K个最大的数

时间复杂度O(log(n))
空间复杂度O(k)

LC相关题目:
347

2.使用quickselect (只能求第k个小的) 见QuickSelect.java
给定一个数组nums和一个k,求第k个小的元素
1)首先进行partition,目标是将数组分为两部分
    1-1: 取得pivot的idx和值,一般取low的地方,pivot作为分割的标尺
    1-2: 设置两个游标p和q,开始从两边向中间遍历(p<=q), p遇到比pivot的值大的停下,q遇到比pivot小的停下,然后交换.
         注意要一直判断p<=q
    1-3: 最终在q和pivotIdx交换数值.至此,数组被分为前边部分小于pivot,后半部分大于等于pivot,而分界点即为q.
2)返回这个分界点q,如果为k -1 等于q,则说明这个位置的数值正好第k个小的元素,否则q如果大于k-1说明要向左找,否则向右找

