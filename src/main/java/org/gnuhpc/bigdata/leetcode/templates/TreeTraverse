0. 综述
遍历方法	            顺序           	       应用
前序	                根 ➜ 左 ➜ 右		       想在节点上直接执行操作（或输出结果）使用先序
中序	                左 ➜ 根 ➜ 右		       在二分搜索树中，中序遍历的顺序符合从小到大（或从大到小）顺序的要输出排序好的结果使用中序
后序	                左 ➜ 右 ➜ 根		       后续遍历的特点是在执行操作时，肯定已经遍历过该节点的左右子节点，适用于进行破坏性操作，比如删除所有节点，比如判断树中是否存在相同子树
广度优先	            层序，横向访问           当树的高度非常高（非常瘦）使用广度优先节省空间
深度优先	            纵向，探底到叶子节点      当每个节点的子节点非常多（非常胖），使用深度优先遍历节省空间（访问顺序和入栈顺序相关，想当于先序遍历）

关于应用部分，选择遍历方法的基本的原则：更快的访问到你想访问的节点。先序会先访问根节点，后序会先访问叶子节点
需要说明的是，递归是一种拆分思维的具体问题类别的思维方法，其核心的思维动态规划非常类似，
都是假设子节点搞定了我现在应该干什么这个问题

前序和中序非递归模板
List<Integer> res = new ArrayList<>();
Deque<TreeNode> stack = new LinkedList<>();
TreeNode p = root;

while (p != null || !stack.isEmpty()) {
    while (p != null) {
        //在这儿访问是前序, 在这儿addFirst倒着保存访问结果是后续
        stack.push(p);
        p = p.left;
    }
    p = stack.pop();
    //在这儿访问是中序
    p = p.right;
}
return res;

后序和上边的不同在于
1. 将TreeNode包裹在一个包装类里，里面记录了是否是第一次被访问
2. 弹出来的时候先看是不是true，如果是，则改为false，塞回去,切换p指向right。如果不是则直接处理

1. 前序遍历可以通过一个辅助结构记录遍历中的结果
LC相关题目：
865

2. 层次遍历为标准BFS
LC相关题目：

3. 前序遍历还有一种先压右边再压左边的做法,
    在修改二叉树结构的时候非常有用, 不会导致丢失另外做题的时候也比较好写

LC相关题目:
257

4. 后序还可以完成多个节点相关的问题,比如节点和, 节点路径问题等
    一般从叶子节点一点点网上构造，看看能得到什么
LC相关题目
687
543
508

5. BST的前序遍历BST，第一个元素值为根节点，小于根节点的元素为左子树，大于根节点的元素为右子树。
   找出分界线（第一个比头部元素大的）然后递归求解一些题
LC相关题目
449


6. BST的前序遍历迭代法中可以进行前后节点的操作
LC相关题目
530

7. BST最基本的概念也会在递归的时候派上用场
LC相关题目
776
653

8. BST的题目也不见得就一定要掉入BST特性的窠臼
LC相关题目
653

9. BST的中序遍历是有序的，这个是BST最基本的， 在中序遍历中可以记录前后的节点情况
LC相关题目
426 解法1
98 解法2和3

10. 如果想获得从叶子节点到根节点的路径，使用前序遍历可以向一个结构的头部不断插入所遍历的元素得到。
LC相关题目
988

11. 前序和中序遍历的时候如何记录上一个遍历的节点，用一个全局变量pre，这一点对于递归还是非递归都一样。
而后续遍历不需要，但是要提前将left和right记录出来

这是个小套路，一般设置一个 TreeNode prev = null;
然后套traverse的框架， 在处理节点时判断prev不是null，则进行判断操作。
不断prev是不是null都记得将prev指向root向后走。

当然如果需要记录遍历到第几个，也可以设置一个全局的count在遍历到节点处理时进行计数。

LC相关题目
426 解法2和3
114 解法1和3
98 解法3
230 解法1

12. 从节点网上遍历一般都采用后序遍历

LC相关题目
545


