0. 综述
遍历方法	            顺序           	       应用
前序	                根 ➜ 左 ➜ 右		       想在节点上直接执行操作（或输出结果）使用先序
中序	                左 ➜ 根 ➜ 右		       在二分搜索树中，中序遍历的顺序符合从小到大（或从大到小）顺序的要输出排序好的结果使用中序
后序	                左 ➜ 右 ➜ 根		       后续遍历的特点是在执行操作时，肯定已经遍历过该节点的左右子节点，适用于进行破坏性操作，比如删除所有节点，比如判断树中是否存在相同子树
广度优先	            层序，横向访问           当树的高度非常高（非常瘦）使用广度优先节省空间
深度优先	            纵向，探底到叶子节点      当每个节点的子节点非常多（非常胖），使用深度优先遍历节省空间（访问顺序和入栈顺序相关，想当于先序遍历）

关于应用部分，选择遍历方法的基本的原则：更快的访问到你想访问的节点。先序会先访问根节点，后序会先访问叶子节点
需要说明的是，递归是一种拆分思维的具体问题类别的思维方法，其核心的思维动态规划非常类似，
都是假设子节点搞定了我现在应该干什么这个问题

1. 前序和后序非递归模板
List<Integer> res = new ArrayList<>();
Deque<TreeNode> stack = new LinkedList<>();
TreeNode p = root;

while (p != null || !stack.isEmpty()) {
    while (p != null) {
        //在这儿访问是前序, 在这儿addFirst倒着保存访问结果是后续
        stack.push(p);
        p = p.left;
    }
    p = stack.pop();
    //在这儿访问是中序
    p = p.right;
}
return res;

LC相关题目

2. 层次遍历为标准BFS
LC相关题目：

3. 前序遍历还有一种先压右边再压左边的做法,
    在修改二叉树结构的时候非常有用, 不会导致丢失另外做题的时候也比较好写

LC相关题目:
257

4. 后序还可以完成路径问题
    一般从叶子节点一点点网上构造，看看能得到什么
LC相关题目
687
543

5. BST的前序遍历BST，第一个元素值为根节点，小于根节点的元素为左子树，大于根节点的元素为右子树。
LC相关题目
449

