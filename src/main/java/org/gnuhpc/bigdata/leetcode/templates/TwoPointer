双指针，主要是处理滑动窗口问题的

模板
int left = 0, right = 0;

while (right < s.size()) {
    window.add(s[right]);
    right++;

    while (valid) {
        window.remove(s[left]);
        left++;
    }
}

类型1：都从一边开始，l和r都是0，然后r往外扩展，到达一定条件后l往里缩，不满足一定条件后r继续往外扩展

如果求最长的子串，则在内循坏后边更新结果，如果求最短的子串，则在内循环里面更新结果
套路模板：
		int[] map = new int[128];

		int counter; // check wether the subtring is valid
		int begin = 0, end = 0; // two pointers, one point to head and one to tail
		int len; //the length of the substring

		char[] chS = s.toCharArray();
		for {
			/* initilize the hash map here */
		}

		while (end < s.length()) {

			if (map[chS[end++]]-- ?) {
				/* modify  counter here */
			}

			while (/* counter condition */) {
				/* update here if find minimum */

				//increase begin to make it invalid/valid again

				if (map[chS[begin++]]++ ?) {
					/* modify counter here */
				}
			}

			/* update d here if find maximum */
		}

		return d // Also be cautious about return conditions. There may be some corner case

LC相关题目
76
438 (方法二是双指针比较数据法)
159
3
30
424
340
159



1. 如果牵涉到计数，可以扣成负数，表述超额扣除的
LC相关题目
76
438

2. 还可以从已给节点向两边扩展，边扩展边进行计算.

3. 有时会和presum进行综合考察
LC相关题目
346

4. 还有一种双指针是快慢指针，也就是同向双指针
LC相关题目
26
82

